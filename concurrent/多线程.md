# 多线程

## 基础概念

1. 进程和线程的区别。
   - 基本概念
     - 进程：系统中**资源分配和调度**的**基本单位**。
       
       > Java中启动main函数就是启动一个JVM的进程。
       >
       > 资源：CPU，IO，内存，文件等等
       
     - 线程：是进程的一个**执行单元**，也被称作轻量级进程。线程不直接分配资源，进程共享进程的资源。操作系统能够进行**运算调度的最小单位**。
       
       > main函数所在线程就是进程中的一个线程，是主线程。
     
   - 区别：
     - **地址空间**：线程共享本进程的地址空间，而进程之间是独立的地址空间。
     
     - **资源**：线程共享本进程的资源：IO, CPU等，进程之间资源独立。
       
       > 从Java内存区域来说，进程有自己的堆和方法区，线程私有虚拟机栈，本地方法栈和程序计数器。
       
     - **切换**：进程切换时消耗资源大，使用线程切换明显优于进程。
   
2. 并发与并行

   并发：同一时段内，多个任务**交替**执行（单位时间片上只有一个任务在执行）
   > 单核 CPU 多任务轮流切换执行：并发

   并行：**CPU单位时间片**内，多个任务**同时**执行。

   > 多核CPU多任务：并行

3. 线程状态

   New：线程被构建，但还没有start()

   Runnable：运行状态。Java中把running和ready统称runnable

   Blocked：阻塞状态，等待获取到锁。

   Waiting：等待状态，需要其他线程做出特定动作来唤醒。

   TIME_Waiting：超市等待状态，不同于waiting，在指定时间自行转成runnable状态

   Terminated：执行完毕。

   <img src = "./img/Java线程状态变化.png" height = 60% width = 60%>

4. 线程死锁。

   死锁必要条件：

   - 互斥：该资源某一时刻只能由**一个线程**占有

   - 请求与保持：线程当请求资源被阻塞时，不放弃已经获得的资源。

     > 在申请资源时一次性申请所有资源

   - 不剥夺：线程已获得的资源在未执行完之前不可以被其他线程强行剥夺，只能在自己使用完之后使用资源。

     > 占用部分资源的线程被阻塞后主动释放自己已占有的资源

   - 循环等待：若干进程之间形成一个头尾相接的循环等待资源关系。

     > 按序申请资源。按正序申请资源，反序释放资源

## 锁

### 锁分类

1. 要不要锁住同步资源？

   **悲观锁**：锁住资源，获取到锁才可以访问。用于容易发生冲突的地方，用于写多的场景。

   **乐观锁**：不锁资源，更新数据时判断是否发生冲突，发生冲突的话再进行修补。用于读多的场景。

2. 获取锁失败，线程要不要阻塞？

   阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间，在某些场景下，同步资源的锁定时间很短，没必要为了这一小段时间去切换线程，可以让后面那个请求锁的线程不放弃CPU的执行时间（稍等一下），让其进行自旋等待获取锁（循环），获取失败的情况下继续自旋直至获取成功。
   
   缺点：虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。
   
   不阻塞的情况下分为**自旋锁**和**适应性自旋锁**。
   
   适应性自旋锁：自旋的时间（次数）不再固定，而是由前一次在同一个锁上的**自旋时间**及**锁的拥有者的状态**来决定。
   
   - 自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。
   - 自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。
   
3. Synchronized锁的状态

   **无锁**：资源没有锁定，所有线程都能访问并修改资源，但同时只能由一个线程修改成功。修改操作在循环内进行，如果没有冲突就修改成功并退出，否则就会继续循环尝试。实现原理详见CAS。

   **偏向锁**：偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。

   - 场景：锁总是由同一线程多次获得，不存在多线程竞争。其目标就是在只有一个线程执行同步代码块时能够提高性能
   - 如何做：线程获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。从原来的获取锁及释放锁需要依赖多次CAS变成置换ThreadID的时候依赖一次CAS原子指令。
   - 当遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。
   
   **轻量级锁**：当锁是偏向锁的时候，被另外的线程所访问，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
   
   - 当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
   
   **重量级锁**：此时等待锁的线程都会进入阻塞状态。
   
4. 多线阻塞排队时允不允许插队？

   排队：**公平锁**。

   - 多个线程按照申请锁的顺序来获取锁，堵塞线程直接进入等待队列中排队。每次
   - 优点：等待锁的线程不会饿死。
   - 缺点：整体吞吐效率相对非公平锁要低。

   允许插队：**非公平锁**。

   - 多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。

   - 优点：减少唤起线程的开销，整体的吞吐效率高。

     来了一个新的线程，它和队列首部的线程竞争锁，因为队列首部的锁要唤起，有一定几率新线程比队列首部的线程快，那么新线程获取到锁。开销就少在**新来的线程可以免去阻塞在唤起的上下文切换开销**。但一旦进入了队列，依旧是FIFO。

   - 缺点：等待队列中的线程可能会饿死/等很久。

5. 一个线程中的多个流程能不能获取同一把锁？

   **可重入锁**：同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class）。

   **非可重入锁**：

6. 多个线程能不能共享同一把锁？

   **独享锁**：该锁可被多个线程所持有。获取独享锁的线程可以读+写。

   **共享锁**：该锁一次只能被一个线程所持有。获取共享锁的线程只可以读。

## Java线程

### 线程实现方式

1. 最基本的两种方式
   - extends thread类，重写run方法
   - implement Runnable接口，实现run方法。
2. 线程池

### synchronized

